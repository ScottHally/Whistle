<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
</head>

<body>
<audio id="gRiff" preload="auto">
	<source src="locoshorter.ogg" type="audio/ogg">
</audio>
<div class="container">
	<div class="row justify-content-center">
		<div class="col">
<canvas id="myCanvas" width="600" height="600"
style="border:1px solid #00d3d3">
Your browser does not support the canvas element.
</canvas>
<!-- remember to use css styles-->

	<canvas id="back" width="600" height="600"
	style="border:1px solid #00d3d3; display: none"></canvas>

<canvas id="greenCircle" width="18" height="18"
style="display: none"></canvas>
</div>
<div class="col-sm pt-4">
	<div class="row justify-content">
<p><button class="btn btn-primary" id="startGame" onclick="startAnimating(20)">PLAY WHISTLE STOP</button></p>
<p><button style="display:none;" class="btn btn-danger" id="stopButton" onclick="toggleWheel()">STOP</button></p>
<p><button class="btn btn-warning" id="testWin" onclick="stopToWin()">TEST</button></p>

<h1 id="winMsg" style="display: none">WIN</h1>
<h1 id="loserMsg" style="display: none">YOU ARE LOSER</h1>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="css/bootstrap.css"/>
<link rel="stylesheet" href="styles.css"/>
<script>
var canvas = document.getElementById("myCanvas");
var ctx = canvas.getContext("2d");
ctx.fillStyle = "#333333";
ctx.fillRect(0,0,600,600);

var circles0 = [];
var circles1 = [];
var circles2 = [];
var gC = document.getElementById("greenCircle");
var gCTX = gC.getContext("2d");
var gFps, fpsInterval, startTime, now, then, elapsed, startFPS;
var stopTime;
var stop = false;
var winPointMarked = false;
var stopPointMarked = false;
var testWinTriggered = false;
var stopTriggered = false;
var stopAtCircle = -1;
var currStopStep = -1;
var reqID;
gCTX.beginPath();
gCTX.arc(9,9,8,0,2*Math.PI);
gCTX.fillStyle = "#ff0000";
	gCTX.stroke();
	gCTX.fill()

var startPoint = {
	x: 300,
	y: 50
};
var endPoint = {
	x: 300,
	y: 50
};

var step = 50;
var xC = canvas.width / 2;
	//console.log('cool' + xC	)
	var yC = canvas.height / 2;
//drawCircle(0,0,2*Math.PI,xC,yC,0.1,220);
	//drawCircle(0,0,2*Math.PI,xC,yC,0.1,200);
	//drawCircle(0,0,2*Math.PI,xC,yC,0.1,250);
	var circle_i = 0;
init();

function init(){
	var xC = canvas.width / 2;
	//console.log('cool' + xC	)
	var yC = canvas.height / 2;

	drawCircle(0,0,2*Math.PI,xC,yC,0.1,220,circles0);
	drawCircle(0,0,2*Math.PI,xC,yC,0.1,200,circles1);
	drawCircle(0,0,2*Math.PI,xC,yC,0.1,240,circles2);
	//ctx.save();
	//startAnimating(20);
	//window.requestAnimationFrame(draw);
}

function stopToWin()
{
	var testWinButton = document.getElementById('testWin');
	testWinTriggered = true;
	console.log('testing win circle');
}

function toggleWheel(){
	var stopButton = document.getElementById('stopButton')
	var winMsg = document.getElementById('winMsg');
	var loserMsg = document.getElementById('loserMsg');

	winMsg.style.display = "none";
	loserMsg.style.display = "none";
	//var gR = document.getElementById('gRiff');
	//gR.play();
	if(stop){
		stop = false;
		stopTriggered = false;
		stopAtCircle = -1;
		reqID = requestAnimationFrame(draw);
		stopButton.innerHTML = "STOP"
		stopTime = null;
		gFps = startFPS;
		fpsInterval = 1000 / gFps;
	}
	else{
		stop = true;
		stopTriggered = true;

		stopButton.style.display = "none";
		stopAtCircle = circle_i + 15;
		//gFps = 15;
		//fpsInterval = 1000 / gFps;
		currStopStep = 0;
		if(stopAtCircle > circles0.length)
		{
			var diff = stopAtCircle - circles0.length;
			stopAtCircle = diff;
		}
		stopTime = Date.now();
		gFps = 15;
		fpsInterval = 1000 / gFps;
		stopButton.innerHTML = "PLAY"
	}
	//cancelAnimationFrame(reqID);
}
//drawTheBloddoyCircle(0,0,0);
function drawTheBloddoyCircle(x,y,colour,circles){
	var c = null;
	for(var i = 0; i < circles.length; i++){
		c = circles[i];
		ctx.beginPath();
		ctx.arc(c.x, c.y,c.r, 0, 2* Math.PI)
		ctx.fillStyle = "#000000";
		ctx.stroke();
		ctx.fill();
	}
}

function thing(ctx,time){
	//ctx.rotate(( Math.PI) * (time.getSeconds() / 60) + 100)
	//ctx.rotate((((5 * Math.PI) / 	60000) * time.getMilliseconds()));
	//ctx.rotate((Math.PI * 2) * (time.getSeconds() / 60))
	ctx.rotate(18 / 180)

}

function animate(){
	// need to throttle, too fast otherwise

}

function startAnimating(fps) {
	var gR = document.getElementById('gRiff');
	//gR.currentTime = 0.5;
	var back = document.getElementById('back');
	var start = document.getElementById('startGame');
	var stopButton = document.getElementById('stopButton');
	stopButton.style.display = "block";
	start.style.display = "none";
	canvas.style.display = "none";
	back.style.display = "inline";
	gR.play();
	console.log(gR.readyState);
    fpsInterval = 1000 / fps;
    startFPS = fps;
    gFps = fps;
    then = Date.now();
    startTime = then;
    draw();

}

function update(context)
{
	context.clearRect(0, 0, 600, 600); // clear canvas

	// 1 green circle
	context.save();
	context.translate(circles0[circle_i].x, circles0[circle_i].y);
  	context.drawImage(gC, -9, -9);
  	context.restore();

  	// 2 green circles
  	context.save();
	context.translate(circles1[circle_i].x, circles1[circle_i].y);
  	context.drawImage(gC, -9, -9);
  	context.restore();

  	// 3 green circles!!
  	context.save();
	context.translate(circles2[circle_i].x, circles2[circle_i].y);
  	context.drawImage(gC, -9, -9);
  	context.restore();

  	context.drawImage(canvas, 0,0,600,600)
}
function draw()
{
	reqID = window.requestAnimationFrame(draw);

	//animatctx.clearRect(0, 0, 300, 300); // clear canvaseCircle(0,0);
	var cool = document.getElementById('back').getContext('2d');


	cool.globalCompositeOperation = 'destination-over';

	now = Date.now();
	
	elapsed = now - then;
	if(elapsed > fpsInterval)
	{
		then = now - (elapsed % fpsInterval);
		if(stopTriggered)
		{

			if(gFps > 5)
			{


				gFps -= 1;
				fpsInterval = 1000 / gFps;
				console.log('setting fps to: ' + gFps);
			}
			currStopStep++;
			//fpsInterval *= 2;
		}
		
		update(cool);
  		if(testWinTriggered && circles0[circle_i].winCircle)
  		{
  			cancelAnimationFrame(reqID);
  		}

  		if(circle_i == stopAtCircle)
		{
		// the amount of circles it should take
		// to successfully stop on the win circle
		// if stopped at the right point
		
		//console.log(now);
		// is there a better way to slow the circle than just throttling the fps?
		//gFps-=3;
		//fpsInterval = 1000 / gFps;

		//stopTime = Date.now(); 
		//console.log(fpsInterval);
		console.log(circles0[circle_i]);
			if(circles0[circle_i].winCircle)
			{
				// everything... seems to be in order...
				//editCircleColour(circles0[circle_i], "#00cc00");
				//editCircleColour(circles1[circle_i], "#00cc00");
				//editCircleColour(circles2[circle_i], "#00cc00");
				gCTX.beginPath();
				gCTX.arc(9,9,8,0,2*Math.PI);
				gCTX.fillStyle = "#00cc00";
				gCTX.stroke();
				gCTX.fill()
				//cool.clearRect(0, 0, 600, 600); // clear canvas
				update(cool);
				gCTX.beginPath();
				gCTX.arc(9,9,8,0,2*Math.PI);
				gCTX.fillStyle = "#ff0000";
				gCTX.stroke();
				gCTX.fill()
		// 1 green circle
	  	//cool.save();
	  	//cool.translate(circles0[circle_i].x, circles0[circle_i].y);
  		//cool.drawImage(gC, -9, -9);
  		//cool.restore();
//
//  		//// 2 green circles
//  		//cool.save();
//	  	//cool.translate(circles1[circle_i].x, circles1[circle_i].y);
//  		//cool.drawImage(gC, -9, -9);
//  		//cool.restore();
//
//  		//// 3 green circles!!
//  		//cool.save();
//	  	//cool.translate(circles2[circle_i].x, circles2[circle_i].y);
//  		//cool.drawImage(gC, -9, -9);
//  		//cool.restore();
//
  		//cool.drawImage(canvas, 0,0,600,600)
  				var winMsg = document.getElementById('winMsg');
  				winMsg.style.display = "block";
				console.log('WIN!!!!')
			}
			else
			{
				var loserMsg = document.getElementById('loserMsg');
				loserMsg.style.display = "block";
			}

			var stopBtn = document.getElementById('stopButton');
			stopBtn.style.display = "block";
			cancelAnimationFrame(reqID);

		
		
	}

  		if(circle_i + 1 == circles0.length)
  		{
  			circle_i = 0;
  		}
  		else
  		{
  			circle_i++;
  		}
	}
}

function moveCircle(){
	 var time = new Date();
  ctx.rotate(((2 * Math.PI) / 60) * time.getSeconds() + ((2 * Math.PI) / 60000) * time.getMilliseconds());
  //ctx.translate(105, 0);
  //ctx.fillRect(0, -12, 40, 24); // Shadow
  //ctx.drawImage(earth, -12, -12);
}
//drawWheel(startPoint,endPoint,step);
function drawWheel(startPoint, endPoint, step){
	//console.log(startPoint.x);
	//console.log(endPoint.y);
	//console.log(step);

	var x = startPoint.x;
	var y = startPoint.y;
	var inc = 0;
	for(var i = 0; i < step; i++){
		ctx.beginPath();
		ctx.arc(x + inc,y + inc,25,0,2*Math.PI);
		ctx.stroke();
		inc += (2 * Math.PI ) / step;
	}

} 

function drawCircle(startX, startY,end, xC, yC, step, inc,circles){
	
	ctx.strokeStyle = "#000000"
	for(var i = 0; i < end; i+=step){
		var stepX = (startX + inc) * Math.cos(i);
		var stepY = (startY + inc) * Math.sin(i);
		var colour = "";
	//	console.log('x: ' + (stepX + xC) + ' y: ' + (stepY + yC))
		if(i < Math.PI && i > Math.PI / 2){
			
			colour = "#990000"
		//console.log("red??")
		}
		else if(i < Math.PI + step && i > Math.PI - step)
		{
			colour = "#990000"
			winPointMarked = true;
		}
		else if(i < Math.PI / 2 + step && i > Math.PI / 2 - step)
		{
			colour = "#b3b300"
			stopPointMarked = true;
		}
		else {
			colour = "#990000"
			//console.log("green???")
		}
		drawCircleRow(stepX + xC, stepY + yC,colour,circles);
	}
}

function drawCircleRow(x,y,colour,circles){
	ctx.beginPath();
	ctx.arc(x,y,8,0, 2*Math.PI);
	//console.log('step is: ' + step)
	//var subArray = [];
	ctx.fillStyle = colour;
	ctx.stroke();
	ctx.fill()
	var circle = {
		x: x,
		y: y,
		r: 8,
		colour: colour,
		winCircle: winPointMarked,
		stopCircle: stopPointMarked
	};
	if(winPointMarked){
		winPointMarked = false;
	}
	if(stopPointMarked){
		stopPointMarked = false;
	}
	//subArray.push(circle);
	circles.push(circle);
	//console.log(circle);
}

function editCircleColour(circle,colour)
{
	console.log('what ' + colour)
	var x = circle.x;
	var y = circle.y;
	ctx.beginPath();
	ctx.arc(x,y,8,0, 2*Math.PI);
	//console.log('step is: ' + step)
	//var subArray = [];
	ctx.fillStyle = colour;
	ctx.stroke();
	ctx.fill()
	circle.colour = colour;
	console.log('new colour...circle');
	console.log(circle);
}

function animateCircle(x,y){
	ctx.strokeStyle = "#000000"
	var xC = canvas.width / 2;
	//console.log('cool' + xC	)
	var yC = canvas.height / 2;
	for(var i = 0; i < 2*Math.PI; i+=0.01){
		var stepX = (x + 220) * Math.cos(i);
		var stepY = (y + 220) * Math.sin(i);
		var colour = "";
	//	console.log('x: ' + (stepX + xC) + ' y: ' + (stepY + yC))
		if(i < Math.PI && i > Math.PI / 2){
			colour = "#ff8080"
		//console.log("red??")
		}
		else {
			colour = "#80ff80"
			//console.log("green???")
		}
		ctx.beginPath();
		ctx.arc(stepX + xC,stepY + yC,10,0, 2*Math.PI);
		//console.log('step is: ' + step)
		
		ctx.fillStyle = colour;
		ctx.stroke();
		ctx.fill()
		//drawCircleRow(stepX + xC, stepY + yC,colour);
	}
}

</script> 

</body>
</html>