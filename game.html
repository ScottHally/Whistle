<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>WHISTLE STOP - SIM 2021</title>
</head>

<body>
<img id="volumeIcon" src="node_modules/bootstrap-icons/icons/volume-off-fill.svg"
width="32" height="32" onclick="toggleAudio('off')">
<img id="muteIcon" src="node_modules/bootstrap-icons/icons/volume-mute-fill.svg"
width="32" height="32" onclick="toggleAudio('on')" style="display: none;">
<audio id="gRiff" preload="auto">
	<source src="locoshorter.ogg" type="audio/ogg">
</audio>

<audio id="arcadeBeep" preload="auto" loop>
	<source src="sounds/arcadebeep.ogg" type="audio/ogg">
</audio>
<div class="container">
	<div class="row justify-content-center">
		<div class="col">
<canvas id="myCanvas" width="600" height="600"
style="border:1px solid #00d3d3; display: none;">
Your browser does not support the canvas element.
</canvas>
<!-- remember to use css styles-->

	<canvas id="back" width="600" height="600"
	style="border:1px solid #00d3d3; display: none"></canvas>

<canvas id="greenCircle" width="18" height="18"
style="display: none"></canvas>
</div>
<div class="col-sm pt-4">
	<div class="row justify-content">
<p><button class="btn btn-primary" id="startGame" onclick="startAnimating(20)">PLAY WHISTLE STOP</button></p>
<p><button style="display:none;" class="btn btn-danger" id="stopButton" onclick="toggleWheel()">STOP</button></p>
<p><button class="btn btn-warning" id="testWin" onclick="stopToWin()">TEST</button></p>
<p><button class="btn btn-warning" id="testWinAnims" onclick="winAnims()">TEST win anims</button></p>
<p><button class="btn btn-warning" id="testWinSpecial" onclick="testWinSpecial()">TEST win special case</button></p>
<h1 id="winMsg" style="display: none">WIN</h1>
<h1 id="loserMsg" style="display: none">YOU ARE LOSER</h1>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="css/bootstrap.css"/>
<link rel="stylesheet" href="styles.css"/>
<script>
var canvas = document.getElementById("myCanvas");
var ctx = canvas.getContext("2d");

var back = document.getElementById('back'); // stop declaring stuff like this locally
// or actually define your functions to take this as a paramater!!!!! its used too often
// to retype over and over!

var backCtx = back.getContext('2d');
back.style.display = "inline";

var arcade = document.getElementById('arcadeBeep');
var gR = document.getElementById('gRiff');
gR.volume = 0.2;
arcade.volume = 0.05;  // this sound is so freakin loud... make sure to go back to mixcraft and dial it down later... WAY DOWN
ctx.fillStyle = "#333333";
ctx.fillRect(0,0,600,600);

var circles0 = [];
var circles1 = [];
var circles2 = [];
var gC = document.getElementById("greenCircle");
var gCTX = gC.getContext("2d");
var gFps, fpsInterval, startTime, now, then, elapsed, startFPS;
var stopTime;
var stop = false;
var winPointMarked = false;
var stopPointMarked = false;
var testWinTriggered = false;
var stopTriggered = false;
var stopAtCircle = -1;
var currStopStep = -1;
var reqID;
var gameEnded = false;
var flip = false;

const END_GAME_FLASHES = 5;
var numFlashes = 0;
gCTX.beginPath();
gCTX.arc(9,9,8,0,2*Math.PI);
gCTX.fillStyle = "#ff0000";
	gCTX.stroke();
	gCTX.fill()

var startPoint = {
	x: 300,
	y: 50
};
var endPoint = {
	x: 300,
	y: 50
};

var step = 50;
var xC = canvas.width / 2;
	//console.log('cool' + xC	)
	var yC = canvas.height / 2;
//drawCircle(0,0,2*Math.PI,xC,yC,0.1,220);
	//drawCircle(0,0,2*Math.PI,xC,yC,0.1,200);
	//drawCircle(0,0,2*Math.PI,xC,yC,0.1,250);
	var circle_i = 0;
	var secondCircle_i = 0;
	var circle_i_0 = 0;
	var circle_i_1 = 0;
	var circle_i_2 = 0;
	var circle_i_3 = 0;

	var circlePos = [0,10,20,30,40,50,0];

	const CIRCLE_GAP = 9;
init();
//welcomeMessage();
function init(){
	var xC = canvas.width / 2;
	//console.log('cool' + xC	)
	var yC = canvas.height / 2;

	drawCircle(0,0,2*Math.PI,xC,yC,0.1,220,circles0);
	drawCircle(0,0,2*Math.PI,xC,yC,0.1,200,circles1);
	drawCircle(0,0,2*Math.PI,xC,yC,0.1,240,circles2);

	console.log('circle array length...');
	console.log(circles0.length);
	//ctx.save();
	//startAnimating(20);
	//window.requestAnimationFrame(draw);
	//back.style.display = "inline";
	canvas.style.display = "inline";
}

function welcomeMessage()
{
	var back = document.getElementById('back');
	var backCtx = back.getContext("2d");
	backCtx.globalCompositeOperation = 'destination-over';
	backCtx.clearRect(0,0,600,600);
	backCtx.textAlign = "center";
	backCtx.font = "30px Arial";
	backCtx.fillText("PLAY WHISTLE STOP", 300,300);
	backCtx.drawImage(canvas,0,0,600,600);
	
	
	setTimeout(function()
	{

		backCtx.clearRect(0,0,600,600);
		backCtx.fillText("3", 300,300);
		backCtx.drawImage(canvas,0,0,600,600);
	}, 1000);
	setTimeout(function()
	{

		backCtx.clearRect(0,0,600,600);
		backCtx.fillText("2", 300,300);
		backCtx.drawImage(canvas,0,0,600,600);
	}, 2000);
	setTimeout(function()
	{

		backCtx.clearRect(0,0,600,600);
		backCtx.fillText("1", 300,300);
		backCtx.drawImage(canvas,0,0,600,600);
	}, 3000);
	setTimeout(function()
	{

		backCtx.clearRect(0,0,600,600);
		backCtx.fillText("GO", 300,300);
		backCtx.drawImage(canvas,0,0,600,600);
	}, 4000);
	setTimeout(function()
	{
		backCtx.clearRect(0,0,600,600);
		backCtx.drawImage(canvas,0,0,600,600);
		reqID = window.requestAnimationFrame(draw);
		arcade.play();
	}, 4500);
	back.style.display = "inline";
}

function winAnims()
{

	if(!flip)
	{
		console.log('Testing win anims');
		gCTX.beginPath();
		gCTX.arc(9,9,8,0,2*Math.PI);
		gCTX.fillStyle = "#00cc00";
		gCTX.stroke();
		gCTX.fill()
	}
	else
	{
		gCTX.beginPath();
		gCTX.arc(9,9,8,0,2*Math.PI);
		gCTX.fillStyle = "#ff0000";
		gCTX.stroke();
		gCTX.fill();
	}

	//cool.clearRect(0, 0, 600, 600); // clear canvas
	

	// huh??
	// why the redraw?
	// ohhh... if we dont do this, the circles stay green
	// if hit replay

}

function toggleAudio(option)
{
	var audioIcon = document.getElementById('volumeIcon');
	var muteIcon = document.getElementById('muteIcon');
	//var gR = document.getElementById('gRiff');
	var audio = document.getElementsByTagName("audio");
	if(option == "off")
	{
		audioIcon.style.display = "none";
		muteIcon.style.display = "block";
		for(var i = 0; i < audio.length; i++)
		{
			audio[i].muted = true;
		}
		
	}
	else 
	{
		muteIcon.style.display = "none";
		audioIcon.style.display = "block";
		for(var i = 0; i < audio.length; i++)
		{
			audio[i].muted = false;
		}
	}
	
}

function testWinSpecial()
{

}

function stopToWin()
{
	var testWinButton = document.getElementById('testWin');
	testWinTriggered = true;
	console.log('testing win circle');
}

function toggleWheel(){
	var stopButton = document.getElementById('stopButton')
	var winMsg = document.getElementById('winMsg');
	var loserMsg = document.getElementById('loserMsg');

	winMsg.style.display = "none";
	loserMsg.style.display = "none";
	//var gR = document.getElementById('gRiff');
	//gR.play();
	if(stop){
		stop = false;
		gameEnded = false;
		stopTriggered = false;
		stopAtCircle = -1;
		flip = true;
		winAnims();
		reqID = requestAnimationFrame(draw);
		stopButton.innerHTML = "STOP"
		stopTime = null;
		gFps = startFPS;
		fpsInterval = 1000 / gFps;

		arcade.play();
	}
	else{
		stop = true;
		stopTriggered = true;

		stopButton.style.display = "none";
		// BE CAREFUL WHEN MODIFYING THIS VARIABLE
		//circle_i = 48; 
		stopAtCircle = circle_i + 15;
		//gFps = 15;
		//fpsInterval = 1000 / gFps;
		currStopStep = 0;

		// everything... seems to be in order...
		if(stopAtCircle >= circles0.length)
		{
			var diff = stopAtCircle - circles0.length;
			stopAtCircle = diff;
		}
		stopTime = Date.now();
		gFps = 15;
		fpsInterval = 1000 / gFps;
		stopButton.innerHTML = "PLAY"
	}
	//cancelAnimationFrame(reqID);
}
//drawTheBloddoyCircle(0,0,0);
function drawTheBloddoyCircle(x,y,colour,circles){
	var c = null;
	for(var i = 0; i < circles.length; i++){
		c = circles[i];
		ctx.beginPath();
		ctx.arc(c.x, c.y,c.r, 0, 2* Math.PI)
		ctx.fillStyle = "#000000";
		ctx.stroke();
		ctx.fill();
	}
}

function thing(ctx,time){
	//ctx.rotate(( Math.PI) * (time.getSeconds() / 60) + 100)
	//ctx.rotate((((5 * Math.PI) / 	60000) * time.getMilliseconds()));
	//ctx.rotate((Math.PI * 2) * (time.getSeconds() / 60))
	ctx.rotate(18 / 180)

}

function animate(){
	// need to throttle, too fast otherwise

}

function startAnimating(fps) {
	var gR = document.getElementById('gRiff');
	//gR.currentTime = 0.5;
	var back = document.getElementById('back');
	var start = document.getElementById('startGame');
	var stopButton = document.getElementById('stopButton');
	stopButton.style.display = "block";
	start.style.display = "none";
	canvas.style.display = "none";
	back.style.display = "inline";
	gR.play();
	//arcade.play();
	console.log(gR.readyState);
    fpsInterval = 1000 / fps;
    startFPS = fps;
    gFps = fps;
    then = Date.now();
    startTime = then;
    welcomeMessage();
    

}

function checkWin()
{
	var circle;
	var winCircleHit = false;

	//FUNNNNCTION!!!!
	circlePos.fill(circle_i);
	if(circles0[circle_i].winCircle)
	{
		console.log('checking first circle...');
		console.log(circles0[circle_i]);
		winCircleHit = true;
	}
	else
	{
		for(var i = 1; i < circlePos.length && !winCircleHit; i++)
		{
			circlePos[i] = circlePos[i-1] + CIRCLE_GAP;
			circlePos[i] = checkBounds(circlePos[i]);
			circle = circles0[circlePos[i]];
			console.log('checking circle...');
			console.log(circle);
			if(circle.winCircle)
			{
				winCircleHit = true;
			}
		}
	}
	

	return winCircleHit;
}

function update(context)
{
	// no no no no no!! so ugly!!
	context.clearRect(0, 0, 600, 600); // clear canvas

	drawThree(context, circle_i);
	circlePos.fill(circle_i);
	for(var i = 1; i < circlePos.length; i++)
	{
		circlePos[i] = circlePos[i-1] + CIRCLE_GAP;
		circlePos[i] = checkBounds(circlePos[i]);
		drawThree(context, circlePos[i]);
	}

  	context.drawImage(canvas, 0,0,600,600);

}

function checkBounds(i)
{
	var diff = -1;
	if(i >= circles0.length)
	{
		diff = i - circles0.length;
		i = diff;
	}
	//console.log(i);
	return i;
}

function drawThree(context, i)
{
	

	// 1 green circle
	context.save();
	context.translate(circles0[i].x, circles0[i].y);
  	context.drawImage(gC, -9, -9);
  	context.restore();

  	// 2 green circles
  	context.save();
	context.translate(circles1[i].x, circles1[i].y);
  	context.drawImage(gC, -9, -9);
  	context.restore();

  	// 3 green circles!!
  	context.save();
	context.translate(circles2[i].x, circles2[i].y);
  	context.drawImage(gC, -9, -9);
  	context.restore();
  	
}

function draw()
{
	reqID = window.requestAnimationFrame(draw);

	//animatctx.clearRect(0, 0, 300, 300); // clear canvaseCircle(0,0);
	var cool = document.getElementById('back').getContext('2d');


	cool.globalCompositeOperation = 'destination-over';

	now = Date.now();
	
	elapsed = now - then;
	if(elapsed > fpsInterval)
	{
		then = now - (elapsed % fpsInterval);
		if(stopTriggered)
		{

			if(gFps > 5)
			{


				gFps -= 1;
				fpsInterval = 1000 / gFps;
				console.log('setting fps to: ' + gFps);
			}
			currStopStep++;
			//fpsInterval *= 2;
		}
		
		update(cool);
  		if(testWinTriggered && circles0[circle_i].winCircle)
  		{
  			cancelAnimationFrame(reqID);
  		}

  		if(circle_i == stopAtCircle)
		{
			gameEnded = true;
		// the amount of circles it should take
		// to successfully stop on the win circle
		// if stopped at the right point
		
		//console.log(now);
		// is there a better way to slow the circle than just throttling the fps?
		//gFps-=3;
		//fpsInterval = 1000 / gFps;

		//stopTime = Date.now(); 
		//console.log(fpsInterval);
			console.log(circles0[circle_i]);


			if(checkWin())
			{
				// everything... seems to be in order...
				//editCircleColour(circles0[circle_i], "#00cc00");
				//editCircleColour(circles1[circle_i], "#00cc00");
				//editCircleColour(circles2[circle_i], "#00cc00");
				flip = !flip;
				winAnims();
				update(cool);
				
				//update(cool);
		// 1 green circle
	  	//cool.save();
	  	//cool.translate(circles0[circle_i].x, circles0[circle_i].y);
  		//cool.drawImage(gC, -9, -9);
  		//cool.restore();
//
//  		//// 2 green circles
//  		//cool.save();
//	  	//cool.translate(circles1[circle_i].x, circles1[circle_i].y);
//  		//cool.drawImage(gC, -9, -9);
//  		//cool.restore();
//
//  		//// 3 green circles!!
//  		//cool.save();
//	  	//cool.translate(circles2[circle_i].x, circles2[circle_i].y);
//  		//cool.drawImage(gC, -9, -9);
//  		//cool.restore();
//
  		//cool.drawImage(canvas, 0,0,600,600)
  				var winMsg = document.getElementById('winMsg');
  				winMsg.style.display = "block";
				console.log('WIN!!!!')
			}
			else
			{
				var loserMsg = document.getElementById('loserMsg');
				loserMsg.style.display = "block";
			}

			var stopBtn = document.getElementById('stopButton');
			stopBtn.style.display = "block";
			arcade.pause();
			arcade.currentTime = 0;
			if(numFlashes > END_GAME_FLASHES)
			{
				numFlashes = 0;
				cancelAnimationFrame(reqID);
				
			}
			else
			{
				numFlashes++;
			}
			

		
		
	}
	else
	{
		console.log('whaaat the fuuu');
		console.log('stopAtCircle last value is.. ' +  stopAtCircle);
	}
		if(!gameEnded)
		{
			if(circle_i + 1 == circles0.length)
	  		{
	  			circle_i = 0;
	  		}
	  		else
	  		{
	  			circle_i++;
	  		}
		}
  		
	}
}

function moveCircle(){
	 var time = new Date();
  ctx.rotate(((2 * Math.PI) / 60) * time.getSeconds() + ((2 * Math.PI) / 60000) * time.getMilliseconds());
  //ctx.translate(105, 0);
  //ctx.fillRect(0, -12, 40, 24); // Shadow
  //ctx.drawImage(earth, -12, -12);
}
//drawWheel(startPoint,endPoint,step);
function drawWheel(startPoint, endPoint, step){
	//console.log(startPoint.x);
	//console.log(endPoint.y);
	//console.log(step);

	var x = startPoint.x;
	var y = startPoint.y;
	var inc = 0;
	for(var i = 0; i < step; i++){
		ctx.beginPath();
		ctx.arc(x + inc,y + inc,25,0,2*Math.PI);
		ctx.stroke();
		inc += (2 * Math.PI ) / step;
	}

} 

function drawCircle(startX, startY,end, xC, yC, step, inc,circles){
	
	ctx.strokeStyle = "#000000"
	for(var i = 0; i < end; i+=step){
		var stepX = (startX + inc) * Math.cos(i);
		var stepY = (startY + inc) * Math.sin(i);
		var colour = "";
	//	console.log('x: ' + (stepX + xC) + ' y: ' + (stepY + yC))
		if(i < Math.PI && i > Math.PI / 2){
			
			colour = "#990000"
		//console.log("red??")
		}
		else if(i < Math.PI + step && i > Math.PI - step)
		{
			colour = "#990000"
			winPointMarked = true;
		}
		else if(i < Math.PI / 2 + step && i > Math.PI / 2 - step)
		{
			colour = "#b3b300"
			stopPointMarked = true;
		}
		else {
			colour = "#990000"
			//console.log("green???")
		}
		drawCircleRow(stepX + xC, stepY + yC,colour,circles);
	}
}

function drawCircleRow(x,y,colour,circles){
	ctx.beginPath();
	ctx.arc(x,y,8,0, 2*Math.PI);
	//console.log('step is: ' + step)
	//var subArray = [];
	ctx.fillStyle = colour;
	ctx.stroke();
	ctx.fill()
	var circle = {
		x: x,
		y: y,
		r: 8,
		colour: colour,
		winCircle: winPointMarked,
		stopCircle: stopPointMarked
	};
	if(winPointMarked){
		winPointMarked = false;
	}
	if(stopPointMarked){
		stopPointMarked = false;
	}
	//subArray.push(circle);
	circles.push(circle);
	//console.log(circle);
}

function editCircleColour(circle,colour)
{
	console.log('what ' + colour)
	var x = circle.x;
	var y = circle.y;
	ctx.beginPath();
	ctx.arc(x,y,8,0, 2*Math.PI);
	//console.log('step is: ' + step)
	//var subArray = [];
	ctx.fillStyle = colour;
	ctx.stroke();
	ctx.fill()
	circle.colour = colour;
	console.log('new colour...circle');
	console.log(circle);
}

function animateCircle(x,y){
	ctx.strokeStyle = "#000000"
	var xC = canvas.width / 2;
	//console.log('cool' + xC	)
	var yC = canvas.height / 2;
	for(var i = 0; i < 2*Math.PI; i+=0.01){
		var stepX = (x + 220) * Math.cos(i);
		var stepY = (y + 220) * Math.sin(i);
		var colour = "";
	//	console.log('x: ' + (stepX + xC) + ' y: ' + (stepY + yC))
		if(i < Math.PI && i > Math.PI / 2){
			colour = "#ff8080"
		//console.log("red??")
		}
		else {
			colour = "#80ff80"
			//console.log("green???")
		}
		ctx.beginPath();
		ctx.arc(stepX + xC,stepY + yC,10,0, 2*Math.PI);
		//console.log('step is: ' + step)
		
		ctx.fillStyle = colour;
		ctx.stroke();
		ctx.fill()
		//drawCircleRow(stepX + xC, stepY + yC,colour);
	}
}

</script> 

</body>
</html>