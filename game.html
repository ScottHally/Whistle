<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
</head>

<body>

<canvas id="myCanvas" width="600" height="600"
style="border:1px solid #00d3d3; display: none">
Your browser does not support the canvas element.
</canvas>
<!-- remember to use css styles-->
<canvas id="back" width="600" height="600"
style="border:1px solid #00d3d3"></canvas>
<canvas id="greenCircle" width="18" height="18"
style="display: none"></canvas>
<button id="stopButton" onclick="toggleWheel()">STOP</button>
<button id="testWin" onclick="stopToWin()">TEST</button>
<script>
var canvas = document.getElementById("myCanvas");
var ctx = canvas.getContext("2d");
var circles0 = [];
var circles1 = [];
var circles2 = [];
var gC = document.getElementById("greenCircle");
var gCTX = gC.getContext("2d");
var gFps, fpsInterval, startTime, now, then, elapsed, startFPS;
var stopTime;
var stop = false;
var winPointMarked = false;
var testWinTriggered = false;

var reqID;
gCTX.beginPath();
gCTX.arc(9,9,8,0,2*Math.PI);
gCTX.fillStyle = "#80ff80";
	gCTX.stroke();
	gCTX.fill()

var startPoint = {
	x: 300,
	y: 50
};
var endPoint = {
	x: 300,
	y: 50
};

var step = 50;
var xC = canvas.width / 2;
	//console.log('cool' + xC	)
	var yC = canvas.height / 2;
//drawCircle(0,0,2*Math.PI,xC,yC,0.1,220);
	//drawCircle(0,0,2*Math.PI,xC,yC,0.1,200);
	//drawCircle(0,0,2*Math.PI,xC,yC,0.1,250);
	var circle_i = 0;
init();

function init(){
	var xC = canvas.width / 2;
	//console.log('cool' + xC	)
	var yC = canvas.height / 2;

	drawCircle(0,0,2*Math.PI,xC,yC,0.1,220,circles0);
	drawCircle(0,0,2*Math.PI,xC,yC,0.1,200,circles1);
	drawCircle(0,0,2*Math.PI,xC,yC,0.1,240,circles2);
	//ctx.save();
	startAnimating(20);
	//window.requestAnimationFrame(draw);
}

function stopToWin()
{
	var testWinButton = document.getElementById('testWin');
	testWinTriggered = true;
	console.log('testing win circle');
}

function toggleWheel(){
	var stopButton = document.getElementById('stopButton')
	if(stop){
		stop = false;
		reqID = requestAnimationFrame(draw);
		stopButton.innerHTML = "STOP"
		stopTime = null;
		gFps = startFPS;
		fpsInterval = 1000 / gFps;
	}
	else{
		stop = true;
		stopTime = Date.now();
		//fpsInterval = 1000 / 5;
		stopButton.innerHTML = "PLAY"
	}
	//cancelAnimationFrame(reqID);
}
//drawTheBloddoyCircle(0,0,0);
function drawTheBloddoyCircle(x,y,colour,circles){
	var c = null;
	for(var i = 0; i < circles.length; i++){
		c = circles[i];
		ctx.beginPath();
		ctx.arc(c.x, c.y,c.r, 0, 2* Math.PI)
		ctx.fillStyle = "#000000";
		ctx.stroke();
		ctx.fill();
	}
}

function thing(ctx,time){
	//ctx.rotate(( Math.PI) * (time.getSeconds() / 60) + 100)
	//ctx.rotate((((5 * Math.PI) / 	60000) * time.getMilliseconds()));
	//ctx.rotate((Math.PI * 2) * (time.getSeconds() / 60))
	ctx.rotate(18 / 180)

}

function animate(){
	// need to throttle, too fast otherwise

}

function startAnimating(fps) {
    fpsInterval = 1000 / fps;
    startFPS = fps;
    gFps = fps;
    then = Date.now();
    startTime = then;
    draw();

}
function draw()
{
	reqID = window.requestAnimationFrame(draw);

	//animatctx.clearRect(0, 0, 300, 300); // clear canvaseCircle(0,0);
	var cool = document.getElementById('back').getContext('2d');


	cool.globalCompositeOperation = 'destination-over';

	now = Date.now();
	if(stopTime != null && now >= stopTime + 300)
	{
		//console.log(now);
		// is there a better way to slow the circle than just throttling the fps?
		gFps-=3;
		fpsInterval = 1000 / gFps;

		stopTime = Date.now(); 
		console.log(fpsInterval);
		if(gFps <= 0){
			if(circles0[circle_i].winCircle)
			{
				// everything... seems to be in order...
				console.log('WIN!!!!')
			}
			cancelAnimationFrame(reqID);

		}
		
	}
	elapsed = now - then;
	if(elapsed > fpsInterval)
	{
		then = now - (elapsed % fpsInterval);
		cool.clearRect(0, 0, 600, 600); // clear canvas

		// 1 green circle
	  	cool.save();
	  	cool.translate(circles0[circle_i].x, circles0[circle_i].y);
  		cool.drawImage(gC, -9, -9);
  		cool.restore();

  		// 2 green circles
  		cool.save();
	  	cool.translate(circles1[circle_i].x, circles1[circle_i].y);
  		cool.drawImage(gC, -9, -9);
  		cool.restore();

  		// 3 green circles!!
  		cool.save();
	  	cool.translate(circles2[circle_i].x, circles2[circle_i].y);
  		cool.drawImage(gC, -9, -9);
  		cool.restore();

  		cool.drawImage(canvas, 0,0,600,600)

  		if(testWinTriggered && circles0[circle_i].winCircle)
  		{
  			cancelAnimationFrame(reqID);
  		}

  		if(circle_i + 1 == circles0.length)
  		{
  			circle_i = 0;
  		}
  		else
  		{
  			circle_i++;
  		}
	}
}

function moveCircle(){
	 var time = new Date();
  ctx.rotate(((2 * Math.PI) / 60) * time.getSeconds() + ((2 * Math.PI) / 60000) * time.getMilliseconds());
  //ctx.translate(105, 0);
  //ctx.fillRect(0, -12, 40, 24); // Shadow
  //ctx.drawImage(earth, -12, -12);
}
//drawWheel(startPoint,endPoint,step);
function drawWheel(startPoint, endPoint, step){
	//console.log(startPoint.x);
	//console.log(endPoint.y);
	//console.log(step);

	var x = startPoint.x;
	var y = startPoint.y;
	var inc = 0;
	for(var i = 0; i < step; i++){
		ctx.beginPath();
		ctx.arc(x + inc,y + inc,25,0,2*Math.PI);
		ctx.stroke();
		inc += (2 * Math.PI ) / step;
	}

} 

function drawCircle(startX, startY,end, xC, yC, step, inc,circles){
	
	ctx.strokeStyle = "#000000"
	for(var i = 0; i < end; i+=step){
		var stepX = (startX + inc) * Math.cos(i);
		var stepY = (startY + inc) * Math.sin(i);
		var colour = "";
	//	console.log('x: ' + (stepX + xC) + ' y: ' + (stepY + yC))
		if(i < Math.PI && i > Math.PI / 2){
			
			colour = "#00cc00"
		//console.log("red??")
		}
		else if(i < Math.PI + step && i > Math.PI - step)
		{
			colour = "#990000"
			winPointMarked = true;
		}
		else {
			colour = "#ff0000"
			//console.log("green???")
		}
		drawCircleRow(stepX + xC, stepY + yC,colour,circles);
	}
}

function drawCircleRow(x,y,colour,circles){
	ctx.beginPath();
	ctx.arc(x,y,8,0, 2*Math.PI);
	//console.log('step is: ' + step)
	//var subArray = [];
	ctx.fillStyle = colour;
	ctx.stroke();
	ctx.fill()
	var circle = {
		x: x,
		y: y,
		r: 8,
		colour: colour,
		winCircle: winPointMarked
	};
	if(winPointMarked){
		winPointMarked = false;
	}
	//subArray.push(circle);
	circles.push(circle);
	//console.log(subArray);
}

function animateCircle(x,y){
	ctx.strokeStyle = "#000000"
	var xC = canvas.width / 2;
	//console.log('cool' + xC	)
	var yC = canvas.height / 2;
	for(var i = 0; i < 2*Math.PI; i+=0.01){
		var stepX = (x + 220) * Math.cos(i);
		var stepY = (y + 220) * Math.sin(i);
		var colour = "";
	//	console.log('x: ' + (stepX + xC) + ' y: ' + (stepY + yC))
		if(i < Math.PI && i > Math.PI / 2){
			colour = "#ff8080"
		//console.log("red??")
		}
		else {
			colour = "#80ff80"
			//console.log("green???")
		}
		ctx.beginPath();
		ctx.arc(stepX + xC,stepY + yC,10,0, 2*Math.PI);
		//console.log('step is: ' + step)
		
		ctx.fillStyle = colour;
		ctx.stroke();
		ctx.fill()
		//drawCircleRow(stepX + xC, stepY + yC,colour);
	}
}

</script> 

</body>
</html>